/*
 * Данные два рукотворные файлы программиста П (DBME280.c, DBME280.h) являются всего лишь прокладками, соединяющими, упро-
 * щающими и сокращающими остальные огромные строки кода из файлов папки BME280 и её подпапки src, которые написаны
 * программистами компании Bosh.
 */





#include <stm32f4xx_hal.h>


#ifdef HAL_SPI_MODULE_ENABLED


#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>

#include "bme280.h"


// "Базовый, абстрактный класс" интерфейса бме280
typedef struct bme_intf_base
{
	// Базовый дескриптор bme из официального драйвера
	struct bme280_dev bme;

	// По хорошему нужно бы тут хранить указатели на все необходимые функции
	// которые могут быть реализованы в "наследниках" по-разному
	// Но в этом нет необходимости, так как все что нам нужно
	// уже хранится в дескрипторе официального драйвера
	// (те самые bme280_read_fptr_t и bme280_write_fptr_t)
} bme_intf_base;


// Теперь "наследник", который реализует работу с bme через SPI на STM32F4
typedef struct bme_intf_spi
{
	// на первом месте в нем стоит структура "базового класса"
	// Поскольку в си указатель на структуру == указателю на её первого члена
	// такой финт ушами позволим нам использовать указатель на "наследника"
	// в тех же местах, где мы используем указатель на "базу"
	bme_intf_base base;

	// по-мимо базы, для работы SPI на stm32 нам так же понадобится
	// хендл SPI шины
	SPI_HandleTypeDef * bus;

	// А вот работу с чип селектом мы "виртуализуем", поскольку у нас есть варианты
	// для прямой работы и через сдвиговый регистр.
	// Аргументами функции делаем эту структуру (по аналогии с this или self)
	// и желаемое состояние чипселекта
	// Договоримся, что active это CS на полу (девайс выбран)
	void (*chip_select)(struct bme_intf_spi * self, bool active);
} bme_intf_spi;


// Еще один наследник, который реализует работу через SPI для BME
typedef struct bme_intf_spi_cs_direct
{
	// Снова, на первом месте "база"
	bme_intf_spi base;

	// Для "прямого" SPI нам нужен GPIO порт и пин чип селекта
	GPIO_TypeDef  * cs_port;
	uint16_t cs_pin;
} bme_intf_spi_cs_direct;


// Альтенативный наследник, для управления чип селектом через сдвиговый регистр
typedef struct bme_intf_spi_cs_shiftreg
{
	// Снова "база"
	bme_intf_spi base;

	// Сдвиговый регистр сам по себе сидит на какой-то SPI шине
	// Вообще в нашем случае он сидит на той же шине и датчик, поэтому это можно выкинуть
	SPI_HandleTypeDef * shift_reg_bus;

	// А еще у него есть а два пина управления - latch и output enable
	GPIO_TypeDef * latch_port;
	uint16_t latch_pin;
	GPIO_TypeDef * oe_port;
	uint16_t oe_pin;

	// Забиваем маской бит, который управлеяет чип селектом датчика
	// "полярность" маски - там где единица, там должно быть 0
	// на регистре для активации датчика
	uint16_t cs_mask;

	// Вообще, мы не можем читать из сдвигового регистра, а использовать его будет сразу кучу программ
	// Например для мигания лампочками
	// Поэтому, если мы хотим только дернуть чип селект для бме
	// Нам нужно изменить один лишь битик, а остальные оставить как есть
	// Но мы можем только закачать все битики в сдвиговый регистр целиком!
	// Как нам узнать какие там были до этого?
	// Придется их где-то хранить у себя и это "где-то" делать доступным для всех программ,
	// которые работают со сдвиговым регистром

	// Короче нужно делать отдельный драйвер сдвигового регистра и сюда пихать его дескриптор
	// указателем. И этот указатель шарить между всему заинтересованными программами

	// Здесь для простоты и наглядности будем считать что сдвиговый регистр используется
	// исключительно для чип селектов, поэтому все остальные биты полюбому нужно ставить в единицу,
	// кроме того чип селекта, который нас интересует
} bme_intf_spi_cs_shiftreg;


// TODO: Дескрипторы для SPI


// Теперь пишем "конструкторы" для всех вариантов
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

// Конструктор для случая работы с датчиком через SPI с "прямым" CS
int bme_ctor_spi_cs_direct(
	bme_intf_spi_cs_direct * device,	/* Дескриптор устройства */
	SPI_HandleTypeDef * bus, 	/* SPI Шина на которой сидит датчик */
	GPIO_TypeDef * cs_port,		/* порт на котором сидит CS пин */
	uint16_t cs_pin				/* собственно CS пин */
);

// Конструктор для случая работы с датчиком через SPI с CS на сдвиговом регистре
int bme_ctor_spi_cs_shiftreg(
	bme_intf_spi_cs_shiftreg * device,	/* Дескриптор устройства */
	SPI_HandleTypeDef * bus,			/* SPI Шина на которой сидит датчик */
	SPI_HandleTypeDef * shiftreg_bus,	/* SPI Шина на которой сидит сдвиговый регистр */
	GPIO_TypeDef * latch_port,			/* Порт на котором сидит latch пин сдвигового регистра */
	uint16_t latch_pin,					/* Пин latch сдвигового регистра */
	GPIO_TypeDef * oe_port,				/* Порт на котором сидит oe пин сдвигого регистра */
	uint16_t oe_pin,					/* oe пин сдвигового регистра */
	uint16_t cs_mask					/* Маска чипселекта */
);

// TODO: Конструкторы для I2C


// А вот теперь функции для работы с датчиком
// Они одинаковые для всех вариантов доступа к датчику
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


/* Создаёт дефолтные настройки, которые написал я и немцы, которые придумали датчик */
int bme_setup_default(
	bme_intf_base * device /* Дескриптор устройства (заметьте, что тут "базовый класс) */
);


// Чтение данных с БМЕ280, может возвращать давление, влажность и температуру
struct bme280_data bme_read_data(
	bme_intf_base * device  /* Дескриптор устройства */
);


#endif
