#ifndef NRF24_UPPER_H_
#define NRF24_UPPER_H_

#include <stm32f4xx_hal.h>

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// Общие определения драйвера
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


// Скорость передачи данных
typedef enum nrf24_data_rate_t
{
	NRF24_DATARATE_250_KBIT,
	NRF24_DATARATE_1000_KBIT,
	NRF24_DATARATE_2000_KBIT
} nrf24_data_rate_t;


// Мощность передатчика
typedef enum nrf24_tx_power_t
{
	NRF24_TXPOWER_MINUS_0_DBM  = 0x03,
	NRF24_TXPOWER_MINUS_6_DBM  = 0x02,
	NRF24_TXPOWER_MINUS_12_DBM = 0x01,
	NRF24_TXPOWER_MINUS_18_DBM = 0x00
} nrf24_tx_power_t;


// Длина CRC
typedef enum nrf24_crc_size_t
{
	NRF24_CRCSIZE_DISABLE, // Не использовать
	NRF24_CRCSIZE_1BYTE,   // 1 байт
	NRF24_CRCSIZE_2BYTE,   // 2 байта
} nrf24_crc_size_t;


// Длина используемого куска адреса пайпа
typedef enum nrf24_address_width_t
{
	NRF24_ADDRES_WIDTH_3_BYTES = 0x01,
	NRF24_ADDRES_WIDTH_4_BYTES = 0x02,
	NRF24_ADDRES_WIDTH_5_BYTES = 0x03,
} nrf24_address_width_t;


// Состояние FIFO буфера
typedef enum nrf24_fifo_status_t
{
	// пустой
	NRF24_FIFO_EMPTY,
	// не пустой и не полный
	NRF24_FIFO_NOT_EMPTY,
	// полный
	NRF24_FIFO_FULL
} nrf24_fifo_status_t;


// Флаги прерывания радио
typedef enum nrf24_irq_t
{
	// Есть данные в RX FIFO
	NRF24_IRQ_RX_DR		= (1 << 2),
	// Пакет из TX FIFO успешно отправлен
	NRF24_IRQ_TX_DR		= (1 << 1),
	// Кончились попытки на отправку пакета из TX FIFO
	NRF24_IRQ_MAX_RT	= (1 << 0),
} nrf24_irq_t;


// Параметры радиоканала
typedef struct nrf24_rf_config_t
{
	// Скорость передачи данных
	nrf24_data_rate_t data_rate;
	// Мощность передатчика
	nrf24_tx_power_t tx_power;
	// Радиоканал. Реальная частота считается как 2400 MHz + rf_channel * 1MHz
	// Допустимые значения от 0 до 125. значение по-умолчанию: 2
	uint8_t rf_channel;
} nrf24_rf_config_t;


// Так же  поступим с настройками "пакетизирования". В отдельную структуру
typedef struct nrf24_protocol_config_t
{
	// Использовать ли CRC и если использовать то как
	nrf24_crc_size_t crc_size;
	// Длина адреса пайпа
	nrf24_address_width_t address_width;

	// Использовать ли пакеты переменной длины
	bool en_dyn_payload_size;
	// Использовать ли ACK пейлоады
	bool en_ack_payload;
	// Разрешить ли отправку отдельных пакетов для которых не ожидается ACK
	// (void * intf_ptr, команда W_TX_PAYLOAD_NOACK)
	bool en_dyn_ack;

	// Количество попыток переотправки пакета (от 0 до 15)
	uint8_t auto_retransmit_count;
	// Пауза между переотправками отправками пакета
	// 0 - 250 мкс, 1 - 500 мкс, ... 15 - 4000мкс (максимум)
	uint8_t auto_retransmit_delay;
} nrf24_protocol_config_t;


// Настройки RX пайпа
typedef struct nrf24_pipe_config_t
{
	// Разрешен ли auto ack на этом пайпе
	// Для работы auto ack он должен быть включен в целом в настройках радио
	bool enable_auto_ack;
	// Адрес пайпа. Длина настраивается отдельно от 3 до 5 байт для 0 и 1 пайпа
	// у остальных пайпов настаивается только младший байт. Остальные совпадают с первым и вторым
	uint64_t address;
	// Размер пайлоада на этом пайпе. Не больше 32. Если указан 0 то пайп не активируется.
	// Если указать < 0, то включаются dyn pld на этом пайпе.
	// Для работы с dyn pld нужно чтобы он был включен в целом
	int8_t payload_size;
} nrf24_pipe_config_t;


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// Общая настройка радио
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

// Настройка радио параметров nrf24
/* Аргументы:
   intf_ptr - указатель, который передается функциям lower_api
   config - структура, содержащая радио праметры nrf24

   Если все хорошо - функция вернет 0. Если плохо - вернет что-то другое */
int nrf24_setup_rf(void * intf_ptr, const nrf24_rf_config_t * config);


// Настройка пакетизирования nrf24
/* Аргументы:
   intf_ptr - указатель, который передается функциям lower_api
   config - структура, содержащая настройки пакетизирования nrf24

   Если все хорошо - функция вернет 0. Если плохо - вернет что-то другое */
int nrf24_setup_protocol(void * intf_ptr, const nrf24_protocol_config_t * config);


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// Настройка пайпов протокола
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

// Настройка и разрешение принимающего пайпа
/* Аргументы:
   intf_ptr - указатель, который передается функциям lower_api
   pipe-no - номер пайпа (от 0 до 5)
   config - настройки пайпа

   Если все хорошо, возвращает 0. Если плохо - вернет что-то другое */
int nrf24_pipe_rx_start(void * intf_ptr, uint8_t pipe_no, const nrf24_pipe_config_t * config);


// Выключение принимающего пайпа
/* Аргументы:
   intf_ptr - указатель, который передается функциям lower_api
   pipe_no - номер пайпа от 0 до 5

   Если все хорошо, возвращает 0. Если плохо - вернет что-то другое */
int nrf24_pipe_rx_stop(void * intf_ptr, uint8_t pipe_no);


// Указание адреса, на который мы будем передавать
/* Аргументы:
   intf_ptr - указатель, который передается функциям lower_api
   tx_addr - адресс, на который передаем. Значимые только 5 младших байт

   Если все хорошо, возвращает 0. Если плохо - вернет что-то другое */
int nrf24_pipe_set_tx_addr(void * intf_ptr, uint64_t tx_addr);


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// Управление режимами радио
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

// Переключение радио в power down режим
/* Аргументы:
   intf_ptr - указатель, который передается функциям lower_api

   Если все хорошо, возвращает 0. Если плохо - вернет что-то другое */
int nrf24_mode_power_down(void * intf_ptr);


// Переключение радио в standby режим
/* Аргументы:
   intf_ptr - указатель, который передается функциям lower_api

   Если все хорошо, возвращает 0. Если плохо - вернет что-то другое */
int nrf24_mode_standby(void * intf_ptr);


// Переключение радио в режим приёма
/* Аргументы:
   intf_ptr - указатель, который передается функциям lower_api

   Если все хорошо, возвращает 0. Если плохо - вернет что-то другое */
int nrf24_mode_tx(void * intf_ptr);


// Переключение радио в режим передачи
/* Аргументы:
   intf_ptr - указатель, который передается функциям lower_api

   Если все хорошо, возвращает 0. Если плохо - вернет что-то другое */
int nrf24_mode_rx(void * intf_ptr);


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// Работа с RX и TX FIFO
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

// Функция для проверки состояния приёмного FIFO (first in first out буфер)
/* Аргументы:
   intf_ptr - указатель, который передается функциям lower_api
   packet_size - по этому указателю функцию запишет размер ожидающего пакета
      Если пакета нет, то запишет 0
   pipe_no - по этому указателю функция запишет номер пайпа с которого пришел пакет
      Если пакета нет - значение не определено (считай любое)
   tx_full - true если TX FIFO забито

   Если все хорошо - функция вернет 0. Если плохо - вернет что-то другое */
int nrf24_fifo_peek(void * intf_ptr, uint8_t * rx_packet_size, uint8_t * rx_pipe_no, bool * tx_full);


// Функция для получения более подробного статуса FIFO (first in first out буфер)
/* Аргументы:
   intf_ptr - указатель, который передается функциям lower_api
   rx_status - по этому указателю запишется заполненость RX FIFO
   tx_status - по этому указателю запишется заполненость TX FIFO

   Если все хорошо - функция вернет 0. Если плохо - вернет что-то другое */
int nrf24_fifo_status(void * intf_ptr, nrf24_fifo_status_t * rx_status, nrf24_fifo_status_t * tx_status);


// Функция для чтения пакета из приёмного FIFO (first in first out буфер)
/* Аргументы:
   intf_ptr - указатель, который передается функциям lower_api
   packet_buffer - указатель на буфер для пакета. Пакеты не бывают больше 32ух байт
   packet_buffer_size - размер передаваемого буфера

   Если пакет в FIFO больше чем передаваемый буфер - функция запишет только то что поместилось,
   а остальные выкинет.
   Вернет функция размер выгребенного пакета (даже если он не влез в буфер)
   Если вернула 0 - никакого пакета в FIFO не было
   Если вернула < 0 - что-то пошло не так */
int nrf24_fifo_read(void * intf_ptr, uint8_t * packet_buffer, uint8_t packet_buffer_size);


// Функция для отправки пакета в радио
/* Аргументы:
   intf_ptr - указатель, который передается функциям lower_api
   packet - указатель на буфер с отправляемым пакетом
   packet_size - размер отправляемого пакета
   use_ack - если включена динамическая ACK-изация пакетов, то сюда можно передать
   false, чтобы пакет был закинут на радио через W_TX_PAYLOAD_NO_ACK команду

   Максимальный размер пакета -32 байта.
   Если дать больше - функция запишет только то что влезло
   Вернет размер записанного куска пакета если все хорошо
   Если дать размер 0 - ничего не сделает и вернет 0
   Если что-то пошло не так вернет < 0 */
int nrf24_fifo_write(void * intf_ptr, const uint8_t * packet, uint8_t packet_size, bool use_ack);

// Запись пакета для отправки вместе с ACK (подтверждение получения пакета)
/* Аргументы:
   intf_ptr - указатель, который передается функциям lower_api
   pipe_no - номер пайпа (от 0 до 5)
   packet - указатель на буфер с отправляемым пакетом
   packet_size - размер отправляемого пакета

   Максимальный размер пакета -32 байта.
   Если дать больше - функция запишет только то что влезло
   Вернет размер записанного куска пакета если все хорошо
   Если дать размер 0 - ничего не сделает и вернет 0
   Если что-то пошло не так вернет < 0  */
int nrf24_fifo_write_ack_pld(void * intf_ptr, uint8_t pipe_no, const uint8_t * packet, uint8_t packet_size);


// Очистка TX FIFO (first in first out буфер)
/* Аргументы:
   intf_ptr - указатель, который передается функциям lower_api

   Если все хорошо - функция вернет 0. Если плохо - вернет что-то другое */
int nrf24_fifo_flush_tx(void * intf_ptr);

// Очистка RX FIFO (first in first out буфер)
/* Аргументы:
   intf_ptr - указатель, который передается функциям lower_api

   Если все хорошо - функция вернет 0. Если плохо - вернет что-то другое */
int nrf24_fifo_flush_rx(void * intf_ptr);


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// Работа с прерываниями
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

// Настройка маски прерываний на пине IRQ
/* Аргументы:
   intf_ptr - указатель, который передается функциям lower_api
   composition - битовая композиция значений nrf24_irq_t, соответствующая
   прерываниям, по котороым радио будет создавать сигнал на IRQ пине
   (то есть маскируются == выключается то прерывания, которые тут не указаны)

   Если все хорошо - вернет 0. Если нет - что-то другое. */
int nrf24_irq_mask_set(void * intf_ptr, int composition);

// Чтение установленной маски прерываний
/* Аргументы:
   intf_ptr - указатель, который передается функциям lower_api
   composition - по этому указателю запишется битовая композиция не маскированных прерываний
   то есть тех, которые будут создавать сигнал на IRQ пине

   Если все хорошо - вернет 0. Если нет - что-то другое */
int nrf24_irq_mask_get(void * intf_ptr, int * composition);

// Получение флагов прерываний от NRF24
/* Аргументы:
   intf_ptr - указатель, который передается функциям lower_api
   composition - по этому указателю будет записана битовая композиция значений nrf24_irq_t
   которая соответствуют набору событий в радио

   Если все хорошо - вернет 0. Если нет - вернет что-то другое */
int nrf24_irq_get(void * intf_ptr, int * composition);


// Очистка флагов прерывания
/* Аргументы:
   intf_ptr - указатель, который передается функциям lower_api
   composition - битовая композиция значений nrf24_irq_t, соответствующая сбрасываемым флагам прерываний

   Если все хорошо - вернет 0. Если нет - вернет что-то другое */
int nrf24_irq_clear(void * intf_ptr, int composition);

#endif /* NRF24_UPPER_H_ */
