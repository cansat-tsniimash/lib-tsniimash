#ifndef NRF24_UPPER_H_
#define NRF24_UPPER_H_

#include <stm32f4xx_hal.h>
#ifdef HAL_SPI_MODULE_ENABLED

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// Общие определения драйвера
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


// Скорость передачи данных
typedef enum nrf24_data_rate_t
{
	NRF24_DATARATE_250_KBIT,
	NRF24_DATARATE_1000_KBIT,
	NRF24_DATARATE_2000_KBIT
} nrf24_data_rate_t;


// Мощность передатчика
typedef enum nrf24_tx_power_t
{
	NRF24_TXPOWER_MINUS_0_DBM  = 0x03,
	NRF24_TXPOWER_MINUS_6_DBM  = 0x02,
	NRF24_TXPOWER_MINUS_12_DBM = 0x01,
	NRF24_TXPOWER_MINUS_18_DBM = 0x00
} nrf24_tx_power_t;


// Длина CRC
typedef enum nrf24_crc_size_t
{
	NRF24_CRCSIZE_DISABLE, // Не использовать
	NRF24_CRCSIZE_1BYTE,   // 1 байт
	NRF24_CRCSIZE_2BYTE,   // 2 байта
} nrf24_crc_size_t;


// Длина используемого куска адреса пайпа
typedef enum nrf24_address_width_t
{
	NRF24_ADDRES_WIDTH_3_BYTES = 0x01,
	NRF24_ADDRES_WIDTH_4_BYTES = 0x02,
	NRF24_ADDRES_WIDTH_5_BYTES = 0x03,
} nrf24_address_width_t;


// Состояние FIFO буфера
typedef enum nrf24_fifo_status_t
{
	// пустой
	NRF24_FIFO_EMPTY,
	// не пустой и не полный
	NRF24_FIFO_NOT_EMPTY,
	// полный
	NRF24_FIFO_FULL
} nrf24_fifo_status_t;


// Флаги прерывания радио
typedef enum nrf24_irq_t
{
	// Есть данные в RX FIFO
	NRF24_IRQ_RX_DR		= (1 << 0),
	// Пакет из TX FIFO успешно отправлен
	NRF24_IRQ_TX_DR		= (1 << 1),
	// Кончились попытки на отправку пакета из TX FIFO
	NRF24_IRQ_MAX_RT	= (1 << 2),
} nrf24_irq_t;


// Параметры радиоканала
typedef struct nrf24_rf_config_t
{
	// Скорость передачи данных
	nrf24_data_rate_t data_rate;
	// Мощность передатчика
	nrf24_tx_power_t tx_power;
	// Радиоканал. Реальная частота считается как 2400 MHz + rf_channel * 1MHz
	// Допустимые значения от 0 до 125. значение по-умолчанию: 2
	uint8_t rf_channel;
} nrf24_rf_config_t;


// Так же  поступим с настройками "пакетизирования". В отдельную структуру
typedef struct nrf24_protocol_config_t
{
	// Использовать ли CRC и если использовать то как
	nrf24_crc_size_t crc_size;
	// Длина адреса пайпа
	nrf24_address_width_t address_width;

	// Использовать ли пакеты переменной длины
	bool en_dyn_payload_size;
	// Использовать ли ACK пейлоады
	bool en_ack_payload;
	// Разрешить ли отправку отдельных пакетов для которых не ожидается ACK
	// (команда W_TX_PAYLOAD_NOACK)
	bool en_dyn_ack;

	// Количество попыток переотправки пакета (от 0 до 15)
	uint8_t auto_retransmit_count;
	// Пауза между переотправками отправками пакета
	// 0 - 250 мкс, 1 - 500 мкс, ... 15 - 4000мкс (максимум)
	uint8_t auto_retransmit_delay;
} nrf24_protocol_config_t;


// Настройки RX пайпа
typedef struct nrf24_pipe_config_t
{
	// Разрешен ли auto ack на этом пайпе
	// Для работы auto ack он должен быть включен в целом в настройках радио
	bool enable_auto_ack;
	// Адрес пайпа. Длина настраивается отдельно от 3 до 5 байт для 0 и 1 пайпа
	// у остальных пайпов настаивается только младший байт. Остальные совпадают с первым и вторым
	uint64_t address;
	// Размер пайлоада на этом пайпе. Не больше 32. Если указан 0 то пайп не активируется.
	// Если указать < 0, то включаются dyn pld на этом пайпе.
	// Для работы с dyn pld нужно чтобы он был включен в целом
	int8_t payload_size;
} nrf24_pipe_config_t;


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// Общая настройка радио
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

// Настройка радио параметров nrf24
/* Если все хорошо, возвращает 0. Если плохо - вернет что-то другое */
int nrf24_setup_rf(const nrf24_rf_config_t * config);


// Настройка пакетизирования nrf24
/* Если все хорошо, возвращает 0. Если плохо - вернет что-то другое */
int nrf24_setup_protocol(const nrf24_protocol_config_t * config);


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// Настройка пайпов протокола
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

// Настройка и разрешение принимающего пайпа
/* pipe-no - номер пайпа (от 0 до 5)
   config - настройки */
/* Если все хорошо, возвращает 0. Если плохо - вернет что-то другое */
int nrf24_pipe_rx_start(uint8_t pipe_no, const nrf24_pipe_config_t * config);


// Выключение принимающего пайпа
/* pipe_no - номер пайпа от 0 до 5
   Если все хорошо, возвращает 0. Если плохо - вернет что-то другое */
int nrf24_pipe_rx_stop(uint8_t pipe_no);


// Указание адреса на который мы будем передавать
/* Значимые только 5 младших байт */
/* Если все хорошо, возвращает 0. Если плохо - вернет что-то другое */
int nrf24_pipe_set_tx_addr(uint64_t tx_addr);


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// Управление режимами радио
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

// Переключение радио в power down режим
/* Если все хорошо, возвращает 0. Если плохо - вернет что-то другое */
int nrf24_mode_power_down(void);


// Переключение радио в standby режим
/* Если все хорошо, возвращает 0. Если плохо - вернет что-то другое */
int nrf24_mode_standby(void);


// Переключение радио в режим приёма
/* Если все хорошо, возвращает 0. Если плохо - вернет что-то другое */
int nrf24_mode_tx(void);


// Переключение радио в режим передачи
/* Если все хорошо, возвращает 0. Если плохо - вернет что-то другое */
int nrf24_mode_rx(void);


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// Работа с RX и TX FIFO
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

// Функция для проверки состояния приёмного FIFO
/* Аргументы:
   packet_size - по этому указателю функцию запишет размер ожидающего пакета
      Если пакета нет, то запишет 0
   pipe_no - по этому указателю функция запишет номер пайпа с которого пришел пакет
      Если пакета нет - значение не определено (считай любое)
   tx_full - true если tx фифо забито

   Если все хорошо - функция вернет 0. Если плохо - вернет что-то другое */
int nrf24_fifo_peek(uint8_t * rx_packet_size, uint8_t * rx_pipe_no, bool * tx_full);


// Функция для получения более подробного статуса фифо
/* Аргументы:
   rx_status - по этому указателю запишется заполненость RX фифо
   tx_status - по этому указателю запишется заполненость TX фифо

   Если все хорошо - функция вернет 0. Если плохо - вернет что-то другое */
int nrf24_fifo_status(nrf24_fifo_status_t * rx_status, nrf24_fifo_status_t * tx_status);


// Функция для чтения пакета из приёмного FIFO
/* Аргументы:
   packet_buffer - указатель на буфер для пакета. Пакеты не бывают больше 32ух байт
   packet_buffer_size - размер передаваемого буфера

   Если пакет в FIFO больше чем передаваемый буфер - функция запишет только то что поместилось,
   а остальные выкинет.
   FIXME: может просто давать ошибку и не выгребать пакет с радио? пусть лежит
   Вернет функция размер выгребенного пакета (даже если он не влез в буфер)
   Если вернула 0 - никакого пакета в фифо не было
   Если вернула < 0 - что-то пошло не так */
int nrf24_fifo_read(uint8_t * packet_buffer, uint8_t packet_buffer_size);


// Функция для отправки пакета в радио
/* Аргументы:
   packet - указатель на буфер с отправляемым пакетом
   packet_size - размер отправляемого пакета
   use_ack - если включена динамическая ACK-изация пакетов, то сюда можно передать
   false, чтобы пакет был закинут на радио через W_TX_PAYLOAD_NO_ACK команду

   Максимальный размер пакета -32 байта.
   Если дать больше - функция запишет только то что влезло
   FIXME: может просто давать ошибку и ничего не писать?
   Вернет размер записанного куска пакета если все хорошо
   Если дать размер 0 - ничего не сделает и вернет 0
   Если что-то пошло не так вернет < 0 */
int nrf24_fifo_write(const uint8_t * packet, uint8_t packet_size, bool use_ack);

// Запись пакета для отправки вместе с ACK
// Аналогична функции nrf24_fifo_write, только позволяет указывать пайп на который пишется
// пакет
int nrf24_fifo_write_ack_pld(uint8_t pipe_no, const uint8_t * packet, uint8_t packet_size);


// Очистка TX FIFO
/* Если все хорошо - функция вернет 0. Если плохо - вернет что-то другое */
int nrf24_fifo_flush_tx(void);

// Очистка RX FIFO
/* Если все хорошо - функция вернет 0. Если плохо - вернет что-то другое */
int nrf24_fifo_flush_rx(void);


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// Работа с прерываниями
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

// Получение флагов прерываний от NRF24
/* Аргументы:
   composition - по этому указателю будет записана битовая композиция значений nrf24_irq_t
   которая соответствуют набору событий в радио

   Если все хорошо - вернет 0. Если нет - вернет что-то другое */
int nrf24_irq_get(int * composition);


// Очистка флагов прерывания
/* Аргументы:
   composition - битовая композиция значений nrf24_irq_t, соответствующая сбрасываемым флагам прерываний

   Если все хорошо - вернет 0. Если нет - вернет что-то другое */
int nrf24_irq_clear(int composition);

#endif /* HAL_SPI_MODULE_ENABLED */
#endif /* NRF24_UPPER_H_ */
