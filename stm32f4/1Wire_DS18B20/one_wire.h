#ifndef ONE_WIRE_H_
#define ONE_WIRE_H_


#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include <stm32f4xx_hal.h>


// Перечисляемый тип разрешения датчика
typedef enum ds18b20_resulution_t
{
	DS18B20_RESOLUTION_9_BIT,  // время измерения < 93.75ms
	DS18B20_RESOLUTION_10_BIT, // время измерения < 187.5ms
	DS18B20_RESOLUTION_11_BIT, // время измерения < 375ms
	DS18B20_RESOLUTION_12_BIT, // время измерения < 750ms
} ds18b20_resulution_t;

//Дескриптор DS18B20
typedef struct {
   GPIO_TypeDef *onewire_port;
   uint16_t onewire_pin;
} ds18b20_t;

//Lower api функции

// Функция прижимает 1w шину к земле
void bus_force_down(ds18b20_t* this);
// Функция отпускает 1w шину (и дальше ей управляют ведомые или никто)
void bus_release(ds18b20_t* this);
// Возвращает текущий логический уровень на 1w шине
bool bus_read(ds18b20_t* this);
// Обновляет значение контольной суммы crc применением всех бит байта b.
// Возвращает обновлённое значение контрольной суммы
uint8_t onewire_crc_update(uint8_t crc, uint8_t b);
// Считает контрольную сумму переданного блока памяти
uint8_t onewire_crc_calc(const uint8_t * data, size_t data_size);

//Upper api функции

// Инициализация необходимой периферии для работы 1w шины
int onewire_init(ds18b20_t* this);


// Канальный уровень
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

// Создание RESET события на 1w шине
/* Если ведомые на шине есть и отзываются на RESET событие
   Функция вернет 0. В случае каких-либо ошибок (например, остутствие ведомых) вернет не 0 */
int onewire_reset(ds18b20_t* this);

// Отправляет указанный бит на 1w шину
void onewire_write_bit(ds18b20_t* this, bool bit);
// Запрашивает очередной бит с 1w шины
bool onewire_read_bit(ds18b20_t* this);
// Отправляет байт на 1w шину
void onewire_write_byte(ds18b20_t* this, uint8_t byte);
// Запрашивает 8 бит на 1w шине и возвращает полученный байт
uint8_t onewire_read_byte(ds18b20_t* this);
// Отправляет buffer_size байт из буфера buffer на 1w шину
void onewire_write(ds18b20_t* this, const uint8_t * buffer, size_t buffer_size);
// Запрашивает buffer_size байт с 1w шины и кладет полученное в buffer
void onewire_read(ds18b20_t* this, uint8_t * buffer, size_t buffer_size);


// Этап адресации
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

// Выдаёт на 1w шину команду пропуска этапа адресации
void onewire_skip_rom(ds18b20_t* this);
// Выдаёт на 1w шину команду на запрос адреса ведомого
/* Команду имеет смысл применять только если взаранее известно,
   что на шине только один ведомый. Адрес ведомого будет записан в rom_buffer
   rom_buffer должен быть массивом длинной не меньше 8 байт, а то быть беде */
void onewire_read_rom(ds18b20_t* this, uint8_t * rom_buffer);

//Функции для работы с DS18B20

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// Настройка датчика
/* alarm_th - температура в градусах для "верхней тревоги"
   alarm_tl - температура в градусах для "нижней тревоги"
   resolution - разрешение замеров (смотри перечисление ds18b20_resulution_t)

   Этап адресации пропускается - работаем с одним или же всеми датчиками на шине сразу.
   Если все прошло хорошо, то функция вернет 0.
   Если что-то пошло не так, например, если ведомый не ответил на RESET событие,
   то функция вернет не 0.

   Для этой команды не предусмотрена проверка целостности данных с
   использованием контрольной суммы, поэтому имеет смысл проверить установленные настройки при
   помощи TODO функции */
int ds18b20_set_config(ds18b20_t* this, int8_t alarm_th, int8_t alarm_tl, ds18b20_resulution_t resolution);

// Запуск процесса измерения
/* Этап адресации пропускается - работаем с одним или же всеми датчиками на шине сразу.
   Если все прошло хорошо, то функция вернет 0.
   Если что-то пошло не так, например, если ведомый не ответил на RESET событие,
   то функция вернет не 0.

   Длительность замера зависит от установленного разрешения.
   При использовании НЕпаразитного питания ds18b20 ведущий может
   запрашивать битки с 1w шины и ds18b20 ответит нулём при завершении замера
   (а еще можно просто подождать, чтобы он точно успел завершиться) */
int ds18b20_start_conversion(ds18b20_t* this);


// Чтение температуры
/* raw_tempareture - указатель на перемееную в которую функция сложит сырое значение температуры
   crc_ok - указатель  на переменную в которую функция сложит результат проверки контроьной суммы
            прочитанного значения. Можно передать 0, если этот флаг не интересен

   Этап адресации пропускается - работаем с единственным ведомым на шине
   Если все прошло хорошо, то функция вернет 0.
   Если что-то пошло не так, например, если ведомый не ответил на RESET событие,
   то функция вернет не 0.

   Температура в градусах получается из сырого значения делением на 16.
   Функция проверяет контрольную сумму полученного значения
   и если контрольная сумма не совпадает, то *crc_ok = false. Если совпадает, то true.*/
int ds18b20_read_raw_temperature(ds18b20_t* this, uint16_t * raw_temperature, bool * crc_ok);


#endif /* ONE_WIRE_H_ */
