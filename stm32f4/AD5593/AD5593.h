#pragma once


#include <stdint.h>
#include <stddef.h>

#include "ad5593_board.h"


//! Адрес ведомого. Два варинта
typedef enum ad5593_addr_t
{
    //! При нуле на A0
    AD5593_ADDR_A0_LOW,
    //! При единице на A0
    AD5593_ADDR_A0_HIGH,
} ad5593_addr_t;


//! Диапазон измерений АЦП и генерации ЦАП
typedef enum ad5593_range_t
{
    // До опорного напряжения (2.5В на внутреннем опорнике)
    AD5593_RANGE_1REF,
    // До двух опорных напряжений (5В на внутреннем опорнике)
    AD5593_RANGE_2REF,
} ad5593_range_t;


//! Аналоговый конфиг прибора
/*! Здесь все очень сложно и нужно читать даташит */
typedef struct ad5593_an_config_t
{
    //! Включить ли буфер на входе АЦП
    /*! Поидее без буфера АЦП всасывает больше тока с измеряемой линии,
        а с буфером медленее работает? */
    bool adc_buffer_enable;
    //! Заряжать ли входной буфер АЦП силами АЦП
    /*! Быстрее работает, в чем минус я не понял */
    bool adc_buffer_precharge;
    //! Диапазон измерений АЦП
    ad5593_range_t adc_range;

    // TODO: настройки для ЦАП

} ad5593_an_config_t;


//! Режим питания ЦАП и опороного источника устройства
typedef enum ad5593_power_t
{
    //! Выключен и опорный источник и ЦАП
    AD5593_POWER_DAC_REF,
    //! Включен только ЦАП (требуется внешний опорник)
    AD5593_POWER_DAC,
    //! Включен и ЦАП и опорник
    AD5593_POWER_NONE,
} ad5593_power_t;


//! Режим работы пина
typedef enum ad5593_pinmode_t
{
    //! Использовать ли этот пин для АЦП
    AD5593_PINMODE_ADC,

    // TODO: остальные режимы
} ad5593_pinmode_t;


//! Идентификатор канала АЦП
typedef enum ad5593_channel_id_t
{
    AD5593_ADC_0 = 0,
    AD5593_ADC_1 = 1,
    AD5593_ADC_2 = 2,
    AD5593_ADC_3 = 3,
    AD5593_ADC_4 = 4,
    AD5593_ADC_5 = 5,
    AD5593_ADC_6 = 6,
    AD5593_ADC_7 = 7,
    //! Встроенный термометр
    AD5593_ADC_TEMP = 8
} ad5593_channel_id_t;


//! Дескриптор устройства
/*! Здесь все инициализируется в ctor функции, самим ничего писать не надо */
typedef struct ad5593_t
{
    //! Дескриптор платформенных штук
    ad5593_board_t * _brd;
    //! Адрес ведомого
    uint8_t _addr;
} ad5593_t;


//! Инициализация дескриптора
int ad5593_ctor(ad5593_t * device, ad5593_addr_t addr, void * board_user_arg);

//! Освобождение ресурсов
void ad5593_dtor(ad5593_t * device);

//! Программный резет
/*! Чип ведет себя по свински и улетает в резет еще до того
    как отправит последний ACK на I2C. Поэтому ошибки от этой
    функции вполне можно ожидать */
int ad5593_sw_reset(ad5593_t * device);

//! Включение/выключение питания
/*! dac_ref позовляет включить или выключить опорник и АЦП
    битвы dac_mask - позволяет включить или выключить отдельные ЦАП линии (1 значит включена) */
int ad5593_power_config(ad5593_t * device, ad5593_power_t power, uint8_t dac_mask);

//! Настройка аналоговой части прибора
int ad5593_an_config(ad5593_t * device, const ad5593_an_config_t * config);

//! Настройка режимов работы пинов
/**! биты в mask позволяют выбрать пины, которые настраиваем
     а моде это собственно режим */
int ad5593_pin_config(ad5593_t * device, uint8_t mask, ad5593_pinmode_t mode);

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// Интерфейс автоматической работы АЦП
// Здесь мы только лишь указываем какие каналы АЦП мы хотим опрашивать
// при помощи функции ad5593_adc_auto_setup
// А переключается оно между ними само.
// Мы лишь читаем очередной замер при помощи функции
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

//! Настройка АЦП для автоматической работы
/*! adc_channels_mask - маска каналов, которые прибор будет опрашивать
        Следует указывать в виде 
        (1 << AD5593_ADC_CHANNEL_1) | (1 << AD5593_ADC_CHANNEL_2) | ...
    repeat - указанные каналы нужно опросить один раз или много 
    */
int ad5593_adc_auto_setup(ad5593_t * device, int adc_channels_mask, bool repeat);

//! Чтение данных очередного замера АЦП
/*! Замер происходит именно вот в момент вызова фунцкии (примерна) */
int ad5593_adc_auto_read(ad5593_t * device, ad5593_channel_id_t * channel, uint16_t * value);

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// Интерфейс "ручной" работы АЦП
// Никакой магии, просто функцией ad5593_adc_read читаем интересующий нас канал
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
int ad5593_adc_read(ad5593_t * device, ad5593_channel_id_t channel, uint16_t * value);
